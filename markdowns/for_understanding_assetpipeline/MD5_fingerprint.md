- 「自分が持っているものと相手が持っているものが本当に同じものかどうかを 確認するのにはどうしたらよいか」という問題は、しばしば議論される問題です。
- いうまでもなく、自分が持っているものと相手が持っているものが同じかどうか、1ビットずつ確認していけばよいわけですが、こと、通信がからむと、これはあまり簡単でない問題です。
- なぜなら、相手の持っている原本と自分の持っているコピーを直接比較する方法がないからです。
- 特に、httpというプロトコルでは内容の照合のような手続きが行なわれないため、仮に通信途中でこわれたとしてもそれを知ることができません。
- 大きなファイルを転送する場合には多少のリスクがあります。
- ところで、何回か再送要求をしても、短いものであれば、通信において大したコストはかかりませんし、途中で壊れる可能性も低いでしょう。
- そこで、原本全体が持っている特徴を表す短いデータ(=fingerprint)を作ってあげて、それをコピーのfingerprintと比較して同一かどうかをチェックすれば、比較的簡単に同一のものかどうかをチェックできると考えられます。
- ここで、fingerprint(原本全体が持っている特徴を表す短いデータ)に対して要求されることは、
- ファイルの内容が少しでも違えば違うfingerprint(原本全体が持っている特徴を表す短いデータ)が出力されること
- 同じfingerprint(原本全体が持っている特徴を表す短いデータ)を持つものを作ることが極めて困難であること
- fingerprint(原本全体が持っている特徴を表す短いデータ)の逆関数が存在しないこと
- といったところでしょうか。
- 通信の途中で悪意を持った人によって改竄されたものとfingerprint(原本全体が持っている特徴を表す短いデータ)が一致してしまっては「問題」です。
- それを防ぐ意味でも この程度の性能は必須と言えるでしょう。
- さて、fingerprintを求めるにあたり、以前はcksumというコマンドでチェックサムを計算していました。
- ところが、これの出力するチェックサムはちょっと短すぎます。
- 今の計算機のパワーを使えば、総当たり戦をやってもそれなりの時間で元のファイルと同じチェックサムを持つファイルを作ることができてしまいます。
- そこで導入されたのがMD5という一方向ハッシュ関数という種類の関数です。
- 出力されるキーの長さが128bitあって、総当たり戦をやるのにはかなりの時間がかかります。
- 当然ながら、先に要求された要件は通常の利用目的の範囲では満たしていることが証明されています。
- (軍事目的とかのレベルだと弱点があることになってますが)
- そんなわけで、MD5によるfingerprint(原本全体が持っている特徴を表す短いデータ)を使うのがかなりメジャーなわけです。
- 最近のUNIX系のOSであれば、md5またはmd5sumという名前のコマンドが標準で入っていると思います。
- このコマンドがあるのは、通信上のチェックのためというよりは、システムの改竄チェックのためですが、当然、この用途にも利用可能です。
- もしも、MD5が手元にない場合ですが、1つの方法はそんな下らないチェックはしないこと、また1つの方法はどこかから手に入れることといったところです。
- md5sumは、GNUのTextUtilsに収録されています。Windowsユーザも、Cygnus辺 りにいけば見つけられるのではないでしょうか。
- Macは・・・どうしましょうね。
- ちなみに、MD5 のアルゴリズムは、RFC1321として公開されています。
- このRFCの中に、C言語のソースが含まれているので、ここから別の言語に翻訳するなり、Cコンパイラを持ってくるなりすればいつでも準備できるわけですが。
- というわけで、MD5 fingerprint(原本全体が持っている特徴を表す短いデータ)を使おうというお話でした。
